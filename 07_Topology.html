<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>7. Topology &mdash; Mathematics in Lean 0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Index" href="genindex.html" />
    <link rel="prev" title="6. Abstract Algebra" href="06_Abstract_Algebra.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Mathematics in Lean
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="01_Introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_Basics.html">2. Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_Logic.html">3. Logic</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_Sets_and_Functions.html">4. Sets and Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_Number_Theory.html">5. Number Theory</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_Abstract_Algebra.html">6. Abstract Algebra</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">7. Topology</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#filters">7.1. Filters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#metric-spaces">7.2. Metric spaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#convergence-and-continuity">7.2.1. Convergence and continuity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#balls-open-sets-and-closed-sets">7.2.2. Balls, open sets and closed sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compactness">7.2.3. Compactness</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uniformly-continuous-functions">7.2.4. Uniformly continuous functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#completeness">7.2.5. Completeness</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Mathematics in Lean</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li><span class="section-number">7. </span>Topology</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/07_Topology.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <span class="target" id="topology"></span><section id="index-0">
<span id="id1"></span><h1><span class="section-number">7. </span>Topology<a class="headerlink" href="#index-0" title="Permalink to this headline">&#61633;</a></h1>
<p>Calculus is based on the concept of a function, which is used to model
quantities that depend on one another.
For example, it is common to study quantities that change over time.
The notion of a <em>limit</em> is also fundamental.
We may say that the limit of a function <span class="math notranslate nohighlight">\(f(x)\)</span> is a value <span class="math notranslate nohighlight">\(b\)</span>
as <span class="math notranslate nohighlight">\(x\)</span> approaches a value <span class="math notranslate nohighlight">\(a\)</span>,
or that <span class="math notranslate nohighlight">\(f(x)\)</span> <em>converges to</em> <span class="math notranslate nohighlight">\(b\)</span> as <span class="math notranslate nohighlight">\(x\)</span> approaches <span class="math notranslate nohighlight">\(a\)</span>.
Equivalently, we may say that a <span class="math notranslate nohighlight">\(f(x)\)</span> approaches <span class="math notranslate nohighlight">\(a\)</span> as <span class="math notranslate nohighlight">\(x\)</span> approaches a value <span class="math notranslate nohighlight">\(b\)</span>, or that it <em>tends to</em> <span class="math notranslate nohighlight">\(b\)</span>
as <span class="math notranslate nohighlight">\(x\)</span> tends to <span class="math notranslate nohighlight">\(a\)</span>.
We have already begun to consider such notions in <a class="reference internal" href="03_Logic.html#sequences-and-convergence"><span class="std std-numref">Section 3.6</span></a>.</p>
<p><em>Topology</em> is the abstract study of limits and continuity.
In this chapter, we will see how topological notions are formalized in mathlib.
Not only do topological abstractions apply in much greater generality,
but that also, somewhat paradoxically, make it easier to reason about limits
and continuity in concrete instances.</p>
<p>Topological notions build on quite a few layers of mathematical structure.
The first layer is naive set theory,
as described in <a class="reference internal" href="04_Sets_and_Functions.html#sets-and-functions"><span class="std std-numref">Chapter 4</span></a>.
The next layer is the theory of <em>filters</em>, which we will describe in <a class="reference internal" href="#filters"><span class="std std-numref">Section 7.1</span></a>.
On top of that, we layer
the theories of <em>topological spaces</em>, <em>metric spaces</em>, and a slightly more exotic
intermediate notion called a <em>uniform space</em>.</p>
<p>Whereas previous chapters relied on mathematical notions that were likely
familiar to you,
the notion of a filter less well known,
even to many working mathematicians.
The notion is essential, however, for formalizing mathematics effectively.
Let us explain why.
Let <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#8477;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code> be any function. We can consider
the limit of <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> as <code class="docutils literal notranslate"><span class="pre">x</span></code> approaches some value <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>,
but we can also consider the limit of <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> as <code class="docutils literal notranslate"><span class="pre">x</span></code> approaches infinity
or negative infinity.
We can moreover consider the limit of <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> as <code class="docutils literal notranslate"><span class="pre">x</span></code> approaches <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> from
the right, conventionally written <code class="docutils literal notranslate"><span class="pre">x&#8320;&#8314;</span></code>, or from the left,
written  <code class="docutils literal notranslate"><span class="pre">x&#8320;&#8315;</span></code>. There are variations where <code class="docutils literal notranslate"><span class="pre">x</span></code> approaches <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> or <code class="docutils literal notranslate"><span class="pre">x&#8320;&#8314;</span></code>
or <code class="docutils literal notranslate"><span class="pre">x&#8320;&#8315;</span></code> but
is not allowed to take on the value <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> itself.
This results in at least eight ways that <code class="docutils literal notranslate"><span class="pre">x</span></code> can approach something.
We can also restrict to rational values of <code class="docutils literal notranslate"><span class="pre">x</span></code>
or place other constraints on the domain, but let&#8217;s stick to those 8 cases.</p>
<p>We have a similar variety of options on the codomain:
we can specify that <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> approaches a value from the left or right,
or that it approaches positive or negative infinity, and so on.
For example, we may wish to say that <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">+&#8734;</span></code>
when <code class="docutils literal notranslate"><span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> from the right without
being equal to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>.
This results in 64 different kinds of limit statements,
and we haven&#8217;t even begun to deal with limits of sequences,
as we did in <a class="reference internal" href="03_Logic.html#sequences-and-convergence"><span class="std std-numref">Section 3.6</span></a>.</p>
<p>The problem is compounded even further when it comes to the supporting lemmas.
For instance, limits compose: if
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">y&#8320;</span></code> when <code class="docutils literal notranslate"><span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> and
<code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">y</span></code> tends to <code class="docutils literal notranslate"><span class="pre">z&#8320;</span></code> when <code class="docutils literal notranslate"><span class="pre">y</span></code> tends to <code class="docutils literal notranslate"><span class="pre">y&#8320;</span></code> then
<code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">&#8728;</span> <span class="pre">f</span> <span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">z&#8320;</span></code> when <code class="docutils literal notranslate"><span class="pre">x</span></code> tends to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>.
There are three notions of &#8220;tends to&#8221; at play here,
each of which can be instantiated in any of the eight ways described
in the previous paragraph.
This results in 512 lemmas, a lot to have to add to a library!
Informally, mathematicians generally prove two or three of these
and simply note that the rest can be proved &#8220;in the same way.&#8221;
Formalizing mathematics requires making the relevant notion of &#8220;sameness&#8221;
fully explicit, and that is exactly what Bourbaki&#8217;s theory of filters
manages to do.</p>
<section id="filters">
<span id="index-1"></span><span id="id2"></span><h2><span class="section-number">7.1. </span>Filters<a class="headerlink" href="#filters" title="Permalink to this headline">&#61633;</a></h2>
<p>A <em>filter</em> on a type <code class="docutils literal notranslate"><span class="pre">X</span></code> is a collection of sets of <code class="docutils literal notranslate"><span class="pre">X</span></code> that satisfies three
conditions that we will spell out below. The notion
supports two related ideas:</p>
<ul class="simple">
<li><p><em>limits</em>, including all the kinds of limits discussed above: finite and infinite limits of sequences, finite and infinite limits of functions at a point or at infinity, and so on.</p></li>
<li><p><em>things happening eventually</em>, including things happening for large enough <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:</span> <span class="pre">&#8469;</span></code>, or sufficiently near a point <code class="docutils literal notranslate"><span class="pre">x</span></code>, or for sufficiently close pairs of points, or almost everywhere in the sense of measure theory. Dually, filters can also express the idea of <em>things happening often</em>: for arbitrarily large <code class="docutils literal notranslate"><span class="pre">n</span></code>, at a point in any neighborhood of given a point, etc.</p></li>
</ul>
<p>The filters that correspond to these descriptions will be defined later in this section, but we can already name them:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(at_top</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">&#8469;)</span></code>, made of sets of <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code> containing <code class="docutils literal notranslate"><span class="pre">{n</span> <span class="pre">|</span> <span class="pre">n</span> <span class="pre">&#8805;</span> <span class="pre">N}</span></code> for some <code class="docutils literal notranslate"><span class="pre">N</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x</span></code>, made of neighborhoods of <code class="docutils literal notranslate"><span class="pre">x</span></code> in a topological space</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#120036;</span> <span class="pre">X</span></code>, made of entourages of a uniform space (uniform spaces generalize metric spaces and topological groups)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&#956;.a_e</span></code> , made of sets whose complement has zero measure with respect to a measure <code class="docutils literal notranslate"><span class="pre">&#956;</span></code>.</p></li>
</ul>
<p>The general definition is as follows: a filter <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X</span></code> is a
collection of sets <code class="docutils literal notranslate"><span class="pre">F.sets</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">(set</span> <span class="pre">X)</span></code> satisfying the following:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">F.univ_sets</span> <span class="pre">:</span> <span class="pre">univ</span> <span class="pre">&#8712;</span> <span class="pre">F.sets</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">F.sets_of_superset</span> <span class="pre">:</span> <span class="pre">&#8704;</span> <span class="pre">{U</span> <span class="pre">V},</span> <span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F.sets</span> <span class="pre">&#8594;</span> <span class="pre">U</span> <span class="pre">&#8838;</span> <span class="pre">V</span> <span class="pre">&#8594;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F.sets</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">F.inter_sets</span> <span class="pre">:</span> <span class="pre">&#8704;</span> <span class="pre">{U</span> <span class="pre">V},</span> <span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F.sets</span> <span class="pre">&#8594;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F.sets</span> <span class="pre">&#8594;</span> <span class="pre">U</span> <span class="pre">&#8745;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F.sets</span></code>.</p></li>
</ul>
<p>The first condition says that the set of all elements of <code class="docutils literal notranslate"><span class="pre">X</span></code> belongs to <code class="docutils literal notranslate"><span class="pre">F.sets</span></code>.
The second condition says that if <code class="docutils literal notranslate"><span class="pre">U</span></code> belongs to <code class="docutils literal notranslate"><span class="pre">F.sets</span></code> then anything
containing <code class="docutils literal notranslate"><span class="pre">U</span></code> also belongs to <code class="docutils literal notranslate"><span class="pre">F.sets</span></code>.
The third condition says that <code class="docutils literal notranslate"><span class="pre">F.sets</span></code> is closed under finite intersections.
In mathlib, a filter <code class="docutils literal notranslate"><span class="pre">F</span></code> is defined to be a structure bundling <code class="docutils literal notranslate"><span class="pre">F.sets</span></code> and its
three properties, but the properties carry no additional data,
and it is convenient to blur the distinction between <code class="docutils literal notranslate"><span class="pre">F</span></code> and <code class="docutils literal notranslate"><span class="pre">F.sets</span></code>. We
therefore define <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code> to mean <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F.sets</span></code>.
This explains why the word <code class="docutils literal notranslate"><span class="pre">sets</span></code> appears in the names of some lemmas that
that mention <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code>.</p>
<p>It may help to think of a filter as defining a notion of a &#8220;sufficiently large&#8221; set. The first
condition then says that <code class="docutils literal notranslate"><span class="pre">univ</span></code> is sufficiently large, the second one says that a set containing a sufficiently
large set is sufficiently large and the third one says that the intersection of two sufficiently large sets
is sufficiently large.</p>
<p>It may be even  more useful to think of a filter on a type <code class="docutils literal notranslate"><span class="pre">X</span></code>
as a generalized element of <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">X</span></code>. For instance, <code class="docutils literal notranslate"><span class="pre">at_top</span></code> is the
&#8220;set of very large numbers&#8221; and <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code> is the &#8220;set of points very close to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>.&#8221;
One manifestation of this view is that we can associate to any <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">X</span></code> the so-called <em>principal filter</em>
consisting of all sets that contain <code class="docutils literal notranslate"><span class="pre">s</span></code>.
This definition is already in mathlib and has a notation <code class="docutils literal notranslate"><span class="pre">&#120031;</span></code> (localized in the <code class="docutils literal notranslate"><span class="pre">filter</span></code> namespace).
For the purpose of demonstration, we ask you to take this opportunity to work out the definition here.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">principal</span> <span class="o">{</span><span class="n">&#945;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">&#945;</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sets</span> <span class="o">:=</span> <span class="o">{</span><span class="n">t</span> <span class="bp">|</span> <span class="n">s</span> <span class="bp">&#8838;</span> <span class="n">t</span><span class="o">},</span>
  <span class="n">univ_sets</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">sets_of_superset</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">inter_sets</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">}</span>
</pre></div>
</div>
<p>For our second example, we ask you to define the filter <code class="docutils literal notranslate"><span class="pre">at_top</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">&#8469;</span></code>.
(We could use any type with a preorder instead of <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code>.)</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">&#8469;</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">sets</span> <span class="o">:=</span> <span class="o">{</span><span class="n">s</span> <span class="bp">|</span> <span class="bp">&#8707;</span> <span class="n">a</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">b</span> <span class="bp">&#8594;</span> <span class="n">b</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">},</span>
  <span class="n">univ_sets</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">sets_of_superset</span> <span class="o">:=</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="n">inter_sets</span> <span class="o">:=</span> <span class="gr">sorry</span> <span class="o">}</span>
</pre></div>
</div>
<p>We can also directly define the filter <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x</span></code> of neighborhoods of any <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:</span> <span class="pre">&#8477;</span></code>.
In the real numbers, a neighborhood of <code class="docutils literal notranslate"><span class="pre">x</span></code> is a set containing an open interval
<span class="math notranslate nohighlight">\((x_0 - \varepsilon, x_0 + \varepsilon)\)</span>,
defined in mathlib as <code class="docutils literal notranslate"><span class="pre">Ioo</span> <span class="pre">(x&#8320;</span> <span class="pre">-</span> <span class="pre">&#949;)</span> <span class="pre">(x&#8320;</span> <span class="pre">+</span> <span class="pre">&#949;)</span></code>.
(This is notion of a neighborhood is only a special case of a more general construction in mathlib.)</p>
<p>With these examples, we can already define what is means for a function <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">Y</span></code>
to converge to some <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">Y</span></code> along some <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X</span></code>,
as follows:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">tendsto&#8321;</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">&#8704;</span> <span class="n">V</span> <span class="bp">&#8712;</span> <span class="n">G</span><span class="o">,</span> <span class="n">f</span> <span class="bp">&#8315;&#185;&#39;</span> <span class="n">V</span> <span class="bp">&#8712;</span> <span class="n">F</span>
</pre></div>
</div>
<p>When <code class="docutils literal notranslate"><span class="pre">X</span></code> is <code class="docutils literal notranslate"><span class="pre">&#8469;</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> is <code class="docutils literal notranslate"><span class="pre">&#8477;</span></code>, <code class="docutils literal notranslate"><span class="pre">tendsto&#8321;</span> <span class="pre">u</span> <span class="pre">at_top</span> <span class="pre">(&#120029;</span> <span class="pre">x)</span></code> is equivalent to saying that the sequence <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code>
converges to the real number <code class="docutils literal notranslate"><span class="pre">x</span></code>. When both <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> are <code class="docutils literal notranslate"><span class="pre">&#8477;</span></code>, <code class="docutils literal notranslate"><span class="pre">tendsto</span> <span class="pre">f</span> <span class="pre">(&#120029;</span> <span class="pre">x&#8320;)</span> <span class="pre">(&#120029;</span> <span class="pre">y&#8320;)</span></code>
is equivalent to the familiar notion <span class="math notranslate nohighlight">\(\lim_{x \to x&#8320;} f(x) = y&#8320;\)</span>.
All of the other kinds of limits mentioned in the introduction are
also equivalent to instances of <code class="docutils literal notranslate"><span class="pre">tendsto&#8321;</span></code> for suitable choices of filters on the source and target.</p>
<p>The notion <code class="docutils literal notranslate"><span class="pre">tendsto&#8321;</span></code> above is definitionally equivalent to the notion <code class="docutils literal notranslate"><span class="pre">tendsto</span></code> that is defined in mathlib,
but the latter is defined more abstractly.
The problem with the definition of <code class="docutils literal notranslate"><span class="pre">tendsto&#8321;</span></code> is that it exposes a quantifier and elements of <code class="docutils literal notranslate"><span class="pre">G</span></code>,
and it hides the intuition that we get by viewing filters as generalized sets. We can
hide the quantifier <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">V</span></code> and make the intuition more salient by using more algebraic and set-theoretic machinery.
The first ingredient is the <em>pushforward</em> operation <span class="math notranslate nohighlight">\(f_*\)</span> associated to any map <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">Y</span></code>,
denoted <code class="docutils literal notranslate"><span class="pre">filter.map</span> <span class="pre">f</span></code> in mathlib. Given a filter <code class="docutils literal notranslate"><span class="pre">F</span></code> on <code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">filter.map</span> <span class="pre">f</span> <span class="pre">F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">Y</span></code> is defined so that
<code class="docutils literal notranslate"><span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">filter.map</span> <span class="pre">f</span> <span class="pre">F</span> <span class="pre">&#8596;</span> <span class="pre">f</span> <span class="pre">&#8315;&#185;'</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code> holds definitionally.
In this examples file we&#8217;ve opened the <code class="docutils literal notranslate"><span class="pre">filter</span></code> namespace so that
<code class="docutils literal notranslate"><span class="pre">filter.map</span></code> can be written as <code class="docutils literal notranslate"><span class="pre">map</span></code>. This means that we can rewrite the definition of <code class="docutils literal notranslate"><span class="pre">tendsto</span></code> using
the order relation on <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">Y</span></code>, which is reversed inclusion of the set of members.
In other words, given <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">H</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">Y</span></code>, we have <code class="docutils literal notranslate"><span class="pre">G</span> <span class="pre">&#8804;</span> <span class="pre">H</span> <span class="pre">&#8596;</span> <span class="pre">&#8704;</span> <span class="pre">V</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">Y,</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">H</span> <span class="pre">&#8594;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">G</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">tendsto&#8322;</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">map</span> <span class="n">f</span> <span class="n">F</span> <span class="bp">&#8804;</span> <span class="n">G</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto&#8322;</span> <span class="n">f</span> <span class="n">F</span> <span class="n">G</span> <span class="bp">&#8596;</span> <span class="n">tendsto&#8321;</span> <span class="n">f</span> <span class="n">F</span> <span class="n">G</span> <span class="o">:=</span> <span class="n">iff.rfl</span>
</pre></div>
</div>
<p>It may seem that the order relation on filters is backward. But recall that we can view filters on <code class="docutils literal notranslate"><span class="pre">X</span></code> as
generalized elements of <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">X</span></code>, via the inclusion of <code class="docutils literal notranslate"><span class="pre">&#120031;</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">filter</span> <span class="pre">X</span></code> which maps any set <code class="docutils literal notranslate"><span class="pre">s</span></code> to the corresponding principal filter.
This inclusion is order preserving, so the order relation on <code class="docutils literal notranslate"><span class="pre">filter</span></code> can indeed be seen as the natural inclusion relation
between generalized sets. In this analogy, pushforward is analogous to the direct image.
And, indeed, <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">f</span> <span class="pre">(&#120031;</span> <span class="pre">s)</span> <span class="pre">=</span> <span class="pre">&#120031;</span> <span class="pre">(f</span> <span class="pre">''</span> <span class="pre">s)</span></code>.</p>
<p>We can now understand intuitively why a sequence <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">:</span> <span class="pre">&#8469;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code> converges to
a point <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> if and only if we have <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">u</span> <span class="pre">at_top</span> <span class="pre">&#8804;</span> <span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code>.
The inequality means the &#8220;direct image under <code class="docutils literal notranslate"><span class="pre">u</span></code>&#8221; of
&#8220;the set of very big natural numbers&#8221; is &#8220;included&#8221; in &#8220;the set of points very close to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>.&#8221;</p>
<p>As promised, the definition of <code class="docutils literal notranslate"><span class="pre">tendsto&#8322;</span></code> does not exhibit any quantifiers or sets.
It also leverages the algebraic properties of the pushforward operation.
First, each <code class="docutils literal notranslate"><span class="pre">filter.map</span> <span class="pre">f</span></code> is monotone. And, second, <code class="docutils literal notranslate"><span class="pre">filter.map</span></code> is compatible with
composition.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="o">(</span><span class="bp">@</span><span class="n">filter.map_mono</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">},</span> <span class="n">monotone</span> <span class="o">(</span><span class="n">map</span> <span class="n">m</span><span class="o">))</span>
<span class="k">#check</span> <span class="o">(</span><span class="bp">@</span><span class="n">filter.map_map</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">&#945;</span><span class="o">}</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">&#945;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">}</span> <span class="o">{</span><span class="n">m&#39;</span> <span class="o">:</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#947;</span><span class="o">},</span>
                            <span class="n">map</span> <span class="n">m&#39;</span> <span class="o">(</span><span class="n">map</span> <span class="n">m</span> <span class="n">f</span><span class="o">)</span> <span class="bp">=</span> <span class="n">map</span> <span class="o">(</span><span class="n">m&#39;</span> <span class="bp">&#8728;</span> <span class="n">m</span><span class="o">)</span> <span class="n">f</span><span class="o">)</span>
</pre></div>
</div>
<p>Together these two properties allow us to prove that limits compose, yielding in one shot all 256 variants
of the composition lemma described in the introduction, and lots more.
You can practice proving the following statement using either the definition
of <code class="docutils literal notranslate"><span class="pre">tendsto&#8321;</span></code> in terms of the
universal quantifier or the algebraic definition,
together with the two lemmas above.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="n">Z</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Y</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">Z</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">&#8594;</span> <span class="n">Z</span><span class="o">}</span>
  <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">tendsto&#8321;</span> <span class="n">f</span> <span class="n">F</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">hg</span> <span class="o">:</span> <span class="n">tendsto&#8321;</span> <span class="n">g</span> <span class="n">G</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">tendsto&#8321;</span> <span class="o">(</span><span class="n">g</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="n">F</span> <span class="n">H</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</pre></div>
</div>
<p>The pushforward construction uses a map to push filters from the map source to the map target.
There also a <em>pullback</em> operation, <code class="docutils literal notranslate"><span class="pre">filter.comap</span></code>, going in the other direction.
This generalizes the
preimage operation on sets. For any map <code class="docutils literal notranslate"><span class="pre">f</span></code>,
<code class="docutils literal notranslate"><span class="pre">filter.map</span> <span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">filter.comap</span> <span class="pre">f</span></code> form what is known as a <em>Galois connection</em>,
which is to say, they satisfy</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">filter.map_le_iff_le_comap</span> <span class="pre">:</span> <span class="pre">filter.map</span> <span class="pre">f</span> <span class="pre">F</span> <span class="pre">&#8804;</span> <span class="pre">G</span> <span class="pre">&#8596;</span> <span class="pre">F</span> <span class="pre">&#8804;</span> <span class="pre">filter.comap</span> <span class="pre">f</span> <span class="pre">G</span></code></p>
</div></blockquote>
<p>for every <code class="docutils literal notranslate"><span class="pre">F</span></code> and <code class="docutils literal notranslate"><span class="pre">G</span></code>.
This operation could be used to provided another formulation of <code class="docutils literal notranslate"><span class="pre">tendsto</span></code> that would be provably
(but not definitionaly) equivalent to the one in mathlib.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">comap</span></code> operation can be used to restrict filters to a subtype. For instance, suppose we have <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">&#8477;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code>,
<code class="docutils literal notranslate"><span class="pre">x&#8320;</span> <span class="pre">:</span> <span class="pre">&#8477;</span></code> and <code class="docutils literal notranslate"><span class="pre">y&#8320;</span> <span class="pre">:</span> <span class="pre">&#8477;</span></code>, and suppose we want to state that <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x</span></code> approaches <code class="docutils literal notranslate"><span class="pre">y&#8320;</span></code> when <code class="docutils literal notranslate"><span class="pre">x</span></code> approaches <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> within the rational numbers.
We can pull the filter <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code> back to <code class="docutils literal notranslate"><span class="pre">&#8474;</span></code> using the coercion map
<code class="docutils literal notranslate"><span class="pre">coe</span> <span class="pre">:</span> <span class="pre">&#8474;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code> and state <code class="docutils literal notranslate"><span class="pre">tendsto</span> <span class="pre">(f</span> <span class="pre">&#8728;</span> <span class="pre">coe</span> <span class="pre">:</span> <span class="pre">&#8474;</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;)</span> <span class="pre">(comap</span> <span class="pre">coe</span> <span class="pre">(&#120029;</span> <span class="pre">x&#8320;))</span> <span class="pre">(&#120029;</span> <span class="pre">y&#8320;)</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="n">y&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span>

<span class="k">#check</span> <span class="n">comap</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">&#8474;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span>
<span class="k">#check</span> <span class="n">tendsto</span> <span class="o">(</span><span class="n">f</span> <span class="bp">&#8728;</span> <span class="n">coe</span><span class="o">)</span> <span class="o">(</span><span class="n">comap</span> <span class="o">(</span><span class="n">coe</span> <span class="o">:</span> <span class="n">&#8474;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">))</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">y&#8320;</span><span class="o">)</span>
</pre></div>
</div>
<p>The pullback operation is also compatible with composition, but it <em>contravariant</em>,
which is to say, it reverses the order of the arguments.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">section</span>
<span class="kd">variables</span> <span class="o">{</span><span class="n">&#945;</span> <span class="n">&#946;</span> <span class="n">&#947;</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">filter</span> <span class="n">&#945;</span><span class="o">)</span> <span class="o">{</span><span class="n">m</span> <span class="o">:</span> <span class="n">&#947;</span> <span class="bp">&#8594;</span> <span class="n">&#946;</span><span class="o">}</span> <span class="o">{</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#946;</span> <span class="bp">&#8594;</span> <span class="n">&#945;</span><span class="o">}</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">comap_comap</span> <span class="o">:</span> <span class="n">comap</span> <span class="n">m</span> <span class="o">(</span><span class="n">comap</span> <span class="n">n</span> <span class="n">F</span><span class="o">)</span> <span class="bp">=</span> <span class="n">comap</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&#8728;</span> <span class="n">m</span><span class="o">)</span> <span class="n">F</span><span class="o">)</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>Let&#8217;s now shift attention to the plane <code class="docutils literal notranslate"><span class="pre">&#8477;</span> <span class="pre">&#215;</span> <span class="pre">&#8477;</span></code> and try to understand how the neighborhoods of a point
<code class="docutils literal notranslate"><span class="pre">(x&#8320;,</span> <span class="pre">y&#8320;)</span></code> are related to <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code> and <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">y&#8320;</span></code>. There is a product operation
<code class="docutils literal notranslate"><span class="pre">filter.prod</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">filter</span> <span class="pre">Y</span> <span class="pre">&#8594;</span> <span class="pre">filter</span> <span class="pre">(X</span> <span class="pre">&#215;</span> <span class="pre">Y)</span></code>, denoted by <code class="docutils literal notranslate"><span class="pre">&#215;&#7584;</span></code>, which answers this question:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="bp">&#120029;</span> <span class="o">(</span><span class="n">x&#8320;</span><span class="o">,</span> <span class="n">y&#8320;</span><span class="o">)</span> <span class="bp">=</span> <span class="bp">&#120029;</span> <span class="n">x&#8320;</span> <span class="bp">&#215;&#7584;</span> <span class="bp">&#120029;</span> <span class="n">y&#8320;</span> <span class="o">:=</span> <span class="n">nhds_prod_eq</span>
</pre></div>
</div>
<p>The product operation is defined in terms of the pullback operation and the <code class="docutils literal notranslate"><span class="pre">inf</span></code> operation:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">&#215;&#7584;</span> <span class="pre">G</span> <span class="pre">=</span> <span class="pre">(comap</span> <span class="pre">prod.fst</span> <span class="pre">F)</span> <span class="pre">&#8851;</span> <span class="pre">(comap</span> <span class="pre">prod.snd</span> <span class="pre">G)</span></code>.</p>
</div></blockquote>
<p>Here the <code class="docutils literal notranslate"><span class="pre">inf</span></code> operation refers to the lattice structure on <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">X</span></code> for any type <code class="docutils literal notranslate"><span class="pre">X</span></code>, whereby
<code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">&#8851;</span> <span class="pre">G</span></code> is the greatest filter that is smaller than both <code class="docutils literal notranslate"><span class="pre">F</span></code> and <code class="docutils literal notranslate"><span class="pre">G</span></code>.
Thus the <code class="docutils literal notranslate"><span class="pre">inf</span></code> operation generalizes the notion of the intersection of sets.</p>
<p>A lot of proofs in mathlib use all of the aforementioned structure (<code class="docutils literal notranslate"><span class="pre">map</span></code>, <code class="docutils literal notranslate"><span class="pre">comap</span></code>, <code class="docutils literal notranslate"><span class="pre">inf</span></code>, <code class="docutils literal notranslate"><span class="pre">sup</span></code>, and <code class="docutils literal notranslate"><span class="pre">prod</span></code>)
to give algebraic proofs about convergence without ever referring to members of filters.
You can practice doing this in a proof of the following lemma, unfolding the definition of <code class="docutils literal notranslate"><span class="pre">tendsto</span></code>
and <code class="docutils literal notranslate"><span class="pre">filter.prod</span></code> if needed.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">le_inf_iff</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span> <span class="bp">&#215;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="n">y&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">f</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="o">(</span><span class="n">x&#8320;</span><span class="o">,</span> <span class="n">y&#8320;</span><span class="o">))</span> <span class="bp">&#8596;</span>
    <span class="n">tendsto</span> <span class="o">(</span><span class="n">prod.fst</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">tendsto</span> <span class="o">(</span><span class="n">prod.snd</span> <span class="bp">&#8728;</span> <span class="n">f</span><span class="o">)</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">y&#8320;</span><span class="o">)</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</pre></div>
</div>
<p>The ordered type <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">X</span></code> is actually a <em>complete</em> lattice,
which is to say, there is a bottom element, there is a top element, and
every set of filters on <code class="docutils literal notranslate"><span class="pre">X</span></code> has an <code class="docutils literal notranslate"><span class="pre">Inf</span></code> and a <code class="docutils literal notranslate"><span class="pre">Sup</span></code>.</p>
<p>Note that given the second property in the definition of a filter
(if <code class="docutils literal notranslate"><span class="pre">U</span></code> belongs to <code class="docutils literal notranslate"><span class="pre">F</span></code> then anything larger than <code class="docutils literal notranslate"><span class="pre">U</span></code> also belongs to <code class="docutils literal notranslate"><span class="pre">F</span></code>),
the first property
(the set of all inhabitants of <code class="docutils literal notranslate"><span class="pre">X</span></code> belongs to <code class="docutils literal notranslate"><span class="pre">F</span></code>) is
equivalent to the property that <code class="docutils literal notranslate"><span class="pre">F</span></code> is not the empty collection of sets.
This shouldn&#8217;t be confused with the more subtle question as to whether
the empty set is an <em>element</em> of <code class="docutils literal notranslate"><span class="pre">F</span></code>. The
definition of a filter does not prohibit <code class="docutils literal notranslate"><span class="pre">&#8709;</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code>,
but if the empty set is in <code class="docutils literal notranslate"><span class="pre">F</span></code> then
every set is in <code class="docutils literal notranslate"><span class="pre">F</span></code>, which is to say, <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">U</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">X,</span> <span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code>.
In this case, <code class="docutils literal notranslate"><span class="pre">F</span></code> is a rather trivial filter, which is precisely the
bottom element of the complete lattice <code class="docutils literal notranslate"><span class="pre">filter</span> <span class="pre">X</span></code>.
This contrasts with the definition of filters in
Bourbaki, which doesn&#8217;t allow filters containing the empty set.</p>
<p>Because we include the trivial filter in our definition, we sometimes need to explicitly assume
nontriviality in some lemmas.
In return, however, the theory has nicer global properties.
We have already seen that including the trivial filter gives us a
bottom element. It also allows us to define <code class="docutils literal notranslate"><span class="pre">principal</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">filter</span> <span class="pre">X</span></code>,
which maps  <code class="docutils literal notranslate"><span class="pre">&#8709;</span></code> to <code class="docutils literal notranslate"><span class="pre">&#8869;</span></code>, without additing a precondition to rule out the empty set.
And it allows us to define the pullback operation without a precondition as well.
Indeed, it can happen that <code class="docutils literal notranslate"><span class="pre">comap</span> <span class="pre">f</span> <span class="pre">F</span> <span class="pre">=</span> <span class="pre">&#8869;</span></code> although <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">&#8800;</span> <span class="pre">&#8869;</span></code>. For instance,
given <code class="docutils literal notranslate"><span class="pre">x&#8320;</span> <span class="pre">:</span> <span class="pre">&#8477;</span></code> and <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">&#8477;</span></code>, the pullback of <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code> under the coercion
from the subtype corresponding to <code class="docutils literal notranslate"><span class="pre">s</span></code> is nontrivial if and only if <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> belongs to the
closure of <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<p>In order to manage lemmas that do need to assume some filter is nontrivial, mathlib has
a type class <code class="docutils literal notranslate"><span class="pre">filter.ne_bot</span></code>, and the library has lemmas that assume
<code class="docutils literal notranslate"><span class="pre">(F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X)</span> <span class="pre">[F.ne_bot]</span></code>. The instance database knows, for example, that <code class="docutils literal notranslate"><span class="pre">(at_top</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">&#8469;).ne_bot</span></code>,
and it knows that pushing forward a nontrivial filter gives a nontrivial filter.
As a result, a lemma assuming <code class="docutils literal notranslate"><span class="pre">[F.ne_bot]</span></code> will automatically apply to <code class="docutils literal notranslate"><span class="pre">map</span> <span class="pre">u</span> <span class="pre">at_top</span></code> for any sequence <code class="docutils literal notranslate"><span class="pre">u</span></code>.</p>
<p>Our tour of the algebraic properties of filters and their relation to limits is essentially done,
but we have not yet justified our claim to have recaptured the usual limit notions.
Superficially, it may seem that <code class="docutils literal notranslate"><span class="pre">tendsto</span> <span class="pre">u</span> <span class="pre">at_top</span> <span class="pre">(&#120029;</span> <span class="pre">x&#8320;)</span></code>
is stronger than the notion of convergence defined in <a class="reference internal" href="03_Logic.html#sequences-and-convergence"><span class="std std-numref">Section 3.6</span></a> because we ask that <em>every</em> neighborhood of <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>
has a preimage belonging to <code class="docutils literal notranslate"><span class="pre">at_top</span></code>, whereas the usual definition only requires
this for the standard neighborhoods <code class="docutils literal notranslate"><span class="pre">Ioo</span> <span class="pre">(x&#8320;</span> <span class="pre">-</span> <span class="pre">&#949;)</span> <span class="pre">(x&#8320;</span> <span class="pre">+</span> <span class="pre">&#949;)</span></code>.
The key is that, by definition, every neighborhood contains such a standard one.
This observation leads to the notion of a <em>filter basis</em>.</p>
<p>Given <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X</span></code>,
a family of sets <cite>s : &#953; &#8594; set X</cite> is a basis for <code class="docutils literal notranslate"><span class="pre">F</span></code> if for every set <code class="docutils literal notranslate"><span class="pre">U</span></code>,
we have <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code> if and only if it contains some <code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">i</span></code>. In other words, formally speaking,
<code class="docutils literal notranslate"><span class="pre">s</span></code> is a basis if it satisfies
<code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">U</span> <span class="pre">:</span> <span class="pre">set</span> <span class="pre">X,</span> <span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span> <span class="pre">&#8596;</span> <span class="pre">&#8707;</span> <span class="pre">i,</span> <span class="pre">s</span> <span class="pre">i</span> <span class="pre">&#8838;</span> <span class="pre">U</span></code>. It is even more flexible to consider
a predicate on <code class="docutils literal notranslate"><span class="pre">&#953;</span></code> that selects only some of the values <code class="docutils literal notranslate"><span class="pre">i</span></code> in the indexing type.
In the case of <code class="docutils literal notranslate"><span class="pre">&#120029;</span> <span class="pre">x&#8320;</span></code>, we want <code class="docutils literal notranslate"><span class="pre">&#953;</span></code> to be <code class="docutils literal notranslate"><span class="pre">&#8477;</span></code>, we write <code class="docutils literal notranslate"><span class="pre">&#949;</span></code> for <code class="docutils literal notranslate"><span class="pre">i</span></code>, and the predicate should select the positive values of <code class="docutils literal notranslate"><span class="pre">&#949;</span></code>.
So the fact that the sets <code class="docutils literal notranslate"><span class="pre">Ioo</span>&#160; <span class="pre">(x&#8320;</span> <span class="pre">-</span> <span class="pre">&#949;)</span> <span class="pre">(x&#8320;</span> <span class="pre">+</span> <span class="pre">&#949;)</span></code> form a basis for the
neighborhood topology on <code class="docutils literal notranslate"><span class="pre">&#8477;</span></code> is stated as follows:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_basis</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">&#949;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">&#949;</span><span class="o">)</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">&#949;</span><span class="o">,</span> <span class="n">Ioo</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="bp">-</span> <span class="n">&#949;</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="bp">+</span> <span class="n">&#949;</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">nhds_basis_Ioo_pos</span> <span class="n">x&#8320;</span>
</pre></div>
</div>
<p>There is also a nice basis for the filter <code class="docutils literal notranslate"><span class="pre">at_top</span></code>. The lemma
<code class="docutils literal notranslate"><span class="pre">filter.has_basis.tendsto_iff</span></code> allows
us to reformulate a statement of the form <code class="docutils literal notranslate"><span class="pre">tendsto</span> <span class="pre">f</span> <span class="pre">F</span> <span class="pre">G</span></code>
given bases for <code class="docutils literal notranslate"><span class="pre">F</span></code> and <code class="docutils literal notranslate"><span class="pre">G</span></code>.
Putting these pieces together gives us essentially the notion of convergence
that we used in <a class="reference internal" href="03_Logic.html#sequences-and-convergence"><span class="std std-numref">Section 3.6</span></a>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">N</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">n</span> <span class="bp">&#8805;</span> <span class="n">N</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">&#8712;</span> <span class="n">Ioo</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="bp">-</span> <span class="n">&#949;</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="bp">+</span> <span class="n">&#949;</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">at_top.has_basis</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">,</span> <span class="n">true</span><span class="o">)</span> <span class="n">Ici</span> <span class="o">:=</span> <span class="n">at_top_basis</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">this.tendsto_iff</span> <span class="o">(</span><span class="n">nhds_basis_Ioo_pos</span> <span class="n">x&#8320;</span><span class="o">),</span>
  <span class="n">simp</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>We now show how filters facilitate working with properties that hold for sufficiently large numbers
or for points that are sufficiently close to a given point. In <a class="reference internal" href="03_Logic.html#sequences-and-convergence"><span class="std std-numref">Section 3.6</span></a>, we were often faced with the situation where
we knew that some property <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code> holds for sufficiently large <code class="docutils literal notranslate"><span class="pre">n</span></code> and that some
other property <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">n</span></code> holds for sufficiently large <code class="docutils literal notranslate"><span class="pre">n</span></code>.
Using <code class="docutils literal notranslate"><span class="pre">cases</span></code> twice gave us <code class="docutils literal notranslate"><span class="pre">N_P</span></code> and <code class="docutils literal notranslate"><span class="pre">N_Q</span></code> satisfying
<code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">n</span> <span class="pre">&#8805;</span> <span class="pre">N_P,</span> <span class="pre">P</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">n</span> <span class="pre">&#8805;</span> <span class="pre">N_Q,</span> <span class="pre">Q</span> <span class="pre">n</span></code>. Using <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">N</span> <span class="pre">:=</span> <span class="pre">max</span> <span class="pre">N_P</span> <span class="pre">N_Q</span></code>, we could
eventually prove <code class="docutils literal notranslate"><span class="pre">&#8704;</span> <span class="pre">n</span> <span class="pre">&#8805;</span> <span class="pre">N,</span> <span class="pre">P</span> <span class="pre">n</span> <span class="pre">&#8743;</span> <span class="pre">Q</span> <span class="pre">n</span></code>.
Doing this repeatedly becomes tiresome.</p>
<p>We can do better by noting that the statement &#8220;<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">n</span></code> hold for large enough <code class="docutils literal notranslate"><span class="pre">n</span></code>&#8221; means
that we have <code class="docutils literal notranslate"><span class="pre">{n</span> <span class="pre">|</span> <span class="pre">P</span> <span class="pre">n}</span> <span class="pre">&#8712;</span> <span class="pre">at_top</span></code> and <code class="docutils literal notranslate"><span class="pre">{n</span> <span class="pre">|</span> <span class="pre">Q</span> <span class="pre">n}</span> <span class="pre">&#8712;</span> <span class="pre">at_top</span></code>.
The fact that <code class="docutils literal notranslate"><span class="pre">at_top</span></code> is a filter implies that the intersection of two elements of <code class="docutils literal notranslate"><span class="pre">at_top</span></code>
is again in <code class="docutils literal notranslate"><span class="pre">at_top</span></code>, so we have <code class="docutils literal notranslate"><span class="pre">{n</span> <span class="pre">|</span> <span class="pre">P</span> <span class="pre">n</span> <span class="pre">&#8743;</span> <span class="pre">Q</span> <span class="pre">n}</span> <span class="pre">&#8712;</span> <span class="pre">at_top</span></code>.
Writing <code class="docutils literal notranslate"><span class="pre">{n</span> <span class="pre">|</span> <span class="pre">P</span> <span class="pre">n}</span> <span class="pre">&#8712;</span> <span class="pre">at_top</span></code> is unpleasant,
but we can use the more suggestive notation <code class="docutils literal notranslate"><span class="pre">&#8704;&#7584;</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">at_top,</span> <span class="pre">P</span> <span class="pre">n</span></code>.
Here the superscripted <code class="docutils literal notranslate"><span class="pre">f</span></code> stands for &#8220;filter.&#8221;
You can think of the notation as saying that for all <code class="docutils literal notranslate"><span class="pre">n</span></code> in the &#8220;set of very large numbers,&#8221; <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code> holds. The <code class="docutils literal notranslate"><span class="pre">&#8704;&#7584;</span></code>
notation stands for <code class="docutils literal notranslate"><span class="pre">filter.eventually</span></code>, and the lemma <code class="docutils literal notranslate"><span class="pre">filter.eventually.and</span></code> uses the intersection property of filters to do what we just described:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hQ</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">Q</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="n">Q</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">hP.and</span> <span class="n">hQ</span>
</pre></div>
</div>
<p>This notation is so convenient and intuitive that we also have specializations
when <code class="docutils literal notranslate"><span class="pre">P</span></code> is an equality or inequality statement. For example, let <code class="docutils literal notranslate"><span class="pre">u</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span></code> be
two sequences of real numbers, and let us show that if
<code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">n</span></code> and <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">n</span></code> coincide for sufficiently large <code class="docutils literal notranslate"><span class="pre">n</span></code> then
<code class="docutils literal notranslate"><span class="pre">u</span></code> tends to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code> if and only if <code class="docutils literal notranslate"><span class="pre">v</span></code> tends to <code class="docutils literal notranslate"><span class="pre">x&#8320;</span></code>.
First we&#8217;ll use the generic <code class="docutils literal notranslate"><span class="pre">eventually</span></code> and then the one
specialized for the equality predicate, <code class="docutils literal notranslate"><span class="pre">eventually_eq</span></code>. The two statements are
definitionaly equivalent so the same proof work in both cases.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">v</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="n">tendsto</span> <span class="n">v</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">tendsto_congr&#39;</span> <span class="n">h</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">u</span> <span class="n">v</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">u</span> <span class="bp">=&#7584;</span><span class="o">[</span><span class="n">at_top</span><span class="o">]</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="n">x&#8320;</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="n">tendsto</span> <span class="n">v</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x&#8320;</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">tendsto_congr&#39;</span> <span class="n">h</span>
</pre></div>
</div>
<p>It is instructive to review the definition of filters in terms of <code class="docutils literal notranslate"><span class="pre">eventually</span></code>.
Given <code class="docutils literal notranslate"><span class="pre">F</span> <span class="pre">:</span> <span class="pre">filter</span> <span class="pre">X</span></code>, for any predicates <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> on <code class="docutils literal notranslate"><span class="pre">X</span></code>,</p>
<ul class="simple">
<li><p>the condition <code class="docutils literal notranslate"><span class="pre">univ</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code> ensures <code class="docutils literal notranslate"><span class="pre">(&#8704;</span> <span class="pre">x,</span> <span class="pre">P</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x</span></code>,</p></li>
<li><p>the condition <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span> <span class="pre">&#8594;</span> <span class="pre">U</span> <span class="pre">&#8838;</span> <span class="pre">V</span> <span class="pre">&#8594;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code> ensures <code class="docutils literal notranslate"><span class="pre">(&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">(&#8704;</span> <span class="pre">x,</span> <span class="pre">P</span> <span class="pre">x</span> <span class="pre">&#8594;</span> <span class="pre">Q</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">Q</span> <span class="pre">x</span></code>, and</p></li>
<li><p>the condition <code class="docutils literal notranslate"><span class="pre">U</span> <span class="pre">&#8712;</span> <span class="pre">F</span> <span class="pre">&#8594;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F</span> <span class="pre">&#8594;</span> <span class="pre">U</span> <span class="pre">&#8745;</span> <span class="pre">V</span> <span class="pre">&#8712;</span> <span class="pre">F</span></code> ensures <code class="docutils literal notranslate"><span class="pre">(&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">(&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">Q</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x</span> <span class="pre">&#8743;</span> <span class="pre">Q</span> <span class="pre">x</span></code>.</p></li>
</ul>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="bp">@</span><span class="n">eventually_of_forall</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">eventually.mono</span>
<span class="k">#check</span> <span class="bp">@</span><span class="n">eventually.and</span>
</pre></div>
</div>
<p>The second item, corresponding to <code class="docutils literal notranslate"><span class="pre">eventually.mono</span></code>, supports nice ways
of using filters, especially when combined
with <code class="docutils literal notranslate"><span class="pre">eventually.and</span></code>. The <code class="docutils literal notranslate"><span class="pre">filter_upwards</span></code> tactic allows us to combine them.
Compare:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hQ</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">Q</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="n">Q</span> <span class="n">n</span> <span class="bp">&#8594;</span> <span class="n">R</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">R</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="o">(</span><span class="n">hP.and</span> <span class="o">(</span><span class="n">hQ.and</span> <span class="n">hR</span><span class="o">))</span><span class="bp">.</span><span class="n">mono</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="n">n</span> <span class="o">&#10216;</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">,</span> <span class="n">h&#39;&#39;</span><span class="o">&#10217;,</span>
  <span class="n">exact</span> <span class="n">h&#39;&#39;</span> <span class="o">&#10216;</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">&#10217;</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="n">R</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">hQ</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">Q</span> <span class="n">n</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hR</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">&#8743;</span> <span class="n">Q</span> <span class="n">n</span> <span class="bp">&#8594;</span> <span class="n">R</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">R</span> <span class="n">n</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">filter_upwards</span> <span class="o">[</span><span class="n">hP</span><span class="o">,</span> <span class="n">hQ</span><span class="o">,</span> <span class="n">hR</span><span class="o">],</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">h</span> <span class="n">h&#39;</span> <span class="n">h&#39;&#39;</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">h&#39;&#39;</span> <span class="o">&#10216;</span><span class="n">h</span><span class="o">,</span> <span class="n">h&#39;</span><span class="o">&#10217;</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>Readers who know about measure theory will note that the filter <code class="docutils literal notranslate"><span class="pre">&#956;.ae</span></code> of sets whose complement has measure zero
(aka &#8220;the set consisting of almost every point&#8221;) is not very useful as the source or target of <code class="docutils literal notranslate"><span class="pre">tendsto</span></code>, but it can be conveniently
used with <code class="docutils literal notranslate"><span class="pre">eventually</span></code> to say that a property holds for almost every point.</p>
<p>There is a dual version of <code class="docutils literal notranslate"><span class="pre">&#8704;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x</span></code>, which is occasionally useful:
<code class="docutils literal notranslate"><span class="pre">&#8707;&#7584;</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">F,</span> <span class="pre">P</span> <span class="pre">x</span></code> means
<code class="docutils literal notranslate"><span class="pre">{x</span> <span class="pre">|</span> <span class="pre">&#172;P</span> <span class="pre">x}</span> <span class="pre">&#8713;</span> <span class="pre">F</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">&#8707;&#7584;</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">at_top,</span> <span class="pre">P</span> <span class="pre">n</span></code> means there are arbitrarily large <code class="docutils literal notranslate"><span class="pre">n</span></code> such that <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code> holds.
The <code class="docutils literal notranslate"><span class="pre">&#8707;&#7584;</span></code> notation stands for <code class="docutils literal notranslate"><span class="pre">filter.frequently</span></code>.</p>
<p>For a more sophisticated example, consider the following statement about a sequence
<code class="docutils literal notranslate"><span class="pre">u</span></code>, a set <code class="docutils literal notranslate"><span class="pre">M</span></code>, and a value <code class="docutils literal notranslate"><span class="pre">x</span></code>:</p>
<blockquote>
<div><p>If <code class="docutils literal notranslate"><span class="pre">u</span></code> converges to <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">n</span></code> belongs to <code class="docutils literal notranslate"><span class="pre">M</span></code> for
sufficiently large <code class="docutils literal notranslate"><span class="pre">n</span></code> then <code class="docutils literal notranslate"><span class="pre">x</span></code> is in the closure of <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p>
</div></blockquote>
<p>This can be formalized as follows:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">tendsto</span> <span class="pre">u</span> <span class="pre">at_top</span> <span class="pre">(&#120029;</span> <span class="pre">x)</span> <span class="pre">&#8594;</span> <span class="pre">(&#8704;&#7584;</span> <span class="pre">n</span> <span class="pre">in</span> <span class="pre">at_top,</span> <span class="pre">u</span> <span class="pre">n</span> <span class="pre">&#8712;</span> <span class="pre">M)</span> <span class="pre">&#8594;</span> <span class="pre">x</span> <span class="pre">&#8712;</span> <span class="pre">closure</span> <span class="pre">M</span></code>.</p>
</div></blockquote>
<p>This is a special case of the theorem <code class="docutils literal notranslate"><span class="pre">mem_closure_of_tendsto</span></code> from the
topology library.
See if you can prove it using the quoted lemmas,
using the fact that <code class="docutils literal notranslate"><span class="pre">cluster_pt</span> <span class="pre">x</span> <span class="pre">F</span></code> means <code class="docutils literal notranslate"><span class="pre">(&#120029;</span> <span class="pre">x</span> <span class="pre">&#8851;</span> <span class="pre">F).ne_bot</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="k">#check</span> <span class="n">mem_closure_iff_cluster_pt</span>
<span class="k">#check</span> <span class="n">le_principal_iff</span>
<span class="k">#check</span> <span class="n">ne_bot_of_le</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">M</span> <span class="o">:</span> <span class="n">set</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span>
  <span class="o">(</span><span class="n">hux</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">huM</span> <span class="o">:</span> <span class="bp">&#8704;&#7584;</span> <span class="n">n</span> <span class="k">in</span> <span class="n">at_top</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">&#8712;</span> <span class="n">M</span><span class="o">)</span> <span class="o">:</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">closure</span> <span class="n">M</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</pre></div>
</div>
</section>
<section id="metric-spaces">
<span id="index-2"></span><span id="id3"></span><h2><span class="section-number">7.2. </span>Metric spaces<a class="headerlink" href="#metric-spaces" title="Permalink to this headline">&#61633;</a></h2>
<p>Examples in the previous section focus on sequences of real numbers. In this section we will go up a bit in generality and focus on
metric spaces. A metric space is a type <code class="docutils literal notranslate"><span class="pre">X</span></code> equipped with a distance function <code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span></code> which is a generalization of
the function <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">x</span> <span class="pre">y,</span> <span class="pre">|x</span> <span class="pre">-</span> <span class="pre">y|</span></code> from the case where <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">&#8477;</span></code>.</p>
<p>Introducing such a space is easy and we will check all properties required from the distance function.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">dist</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">dist_nonneg</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&#8804;</span> <span class="n">dist</span> <span class="n">a</span> <span class="n">b</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">dist_eq_zero</span> <span class="o">:</span> <span class="n">dist</span> <span class="n">a</span> <span class="n">b</span>  <span class="bp">=</span> <span class="mi">0</span> <span class="bp">&#8596;</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">dist_comm</span> <span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">dist</span> <span class="n">a</span> <span class="n">b</span>  <span class="bp">=</span> <span class="n">dist</span> <span class="n">b</span> <span class="n">a</span><span class="o">)</span>

<span class="k">#check</span> <span class="o">(</span><span class="n">dist_triangle</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="o">:</span> <span class="n">dist</span> <span class="n">a</span> <span class="n">c</span> <span class="bp">&#8804;</span> <span class="n">dist</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">+</span> <span class="n">dist</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span>
</pre></div>
</div>
<p>Note we also have variants where the distance can be infinite or where <code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">a</span> <span class="pre">b</span></code> can be zero without having <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code> or both.
They are called <code class="docutils literal notranslate"><span class="pre">emetric_space</span></code>, <code class="docutils literal notranslate"><span class="pre">pseudo_metric_space</span></code> and <code class="docutils literal notranslate"><span class="pre">pseudo_emetric_space</span></code> respectively (here &#8220;e&#8221; stands for &#8220;extended&#8221;).</p>
<p>Note that our journey from <code class="docutils literal notranslate"><span class="pre">&#8477;</span></code> to metric spaces jumped over the special case of normed spaces that also require linear algebra and
will be explained as part of the calculus chapter.</p>
<section id="convergence-and-continuity">
<h3><span class="section-number">7.2.1. </span>Convergence and continuity<a class="headerlink" href="#convergence-and-continuity" title="Permalink to this headline">&#61633;</a></h3>
<p>Using distance functions, we can already define convergent sequences and continuous functions between metric spaces.
They are actually defined in a more general setting covered in the next section,
but we have lemmas recasting the definition is terms of distances.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&#8596;</span> <span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">N</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">n</span> <span class="bp">&#8805;</span> <span class="n">N</span><span class="o">,</span> <span class="n">dist</span> <span class="o">(</span><span class="n">u</span> <span class="n">n</span><span class="o">)</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="o">:=</span>
<span class="n">metric.tendsto_at_top</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="n">f</span> <span class="bp">&#8596;</span>
  <span class="bp">&#8704;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">&#948;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">x&#39;</span><span class="o">,</span> <span class="n">dist</span> <span class="n">x&#39;</span> <span class="n">x</span> <span class="bp">&lt;</span> <span class="n">&#948;</span> <span class="bp">&#8594;</span> <span class="n">dist</span> <span class="o">(</span><span class="n">f</span> <span class="n">x&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="o">:=</span>
<span class="n">metric.continuous_iff</span>
</pre></div>
</div>
<p id="index-3">A <em>lot</em> of lemmas have some continuity assumptions, no we end up proving a lot of continuity results and there
is a <code class="docutils literal notranslate"><span class="pre">continuity</span></code> tactic devoted to this task. Let&#8217;s prove a continuity statement that will be needed
in an exercise below. Notice that Lean knows how to treat a product of two metric spaces as a metric space, so
it makes sense to consider continuous functions from <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">&#215;</span> <span class="pre">X</span></code> to <code class="docutils literal notranslate"><span class="pre">&#8477;</span></code>.
In particular the (uncurried version of the) distance function is such a function.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#215;</span> <span class="n">X</span><span class="o">,</span> <span class="n">dist</span> <span class="o">(</span><span class="n">f</span> <span class="n">p.1</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">p.2</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">by</span> <span class="n">continuity</span>
</pre></div>
</div>
<p>This tactic is a bit slow, so it is also useful to know
how to do it by hand. We first need to use that <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">p</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#215;</span> <span class="pre">X,</span> <span class="pre">f</span> <span class="pre">p.1</span></code> is continuous because it
is the composition of <code class="docutils literal notranslate"><span class="pre">f</span></code>, which is continuous by assumption <code class="docutils literal notranslate"><span class="pre">hf</span></code>, and the projection <code class="docutils literal notranslate"><span class="pre">prod.fst</span></code> whose continuity
is the content of the lemma <code class="docutils literal notranslate"><span class="pre">continuous_fst</span></code>. The composition property is <code class="docutils literal notranslate"><span class="pre">continuous.comp</span></code> which is
in the <code class="docutils literal notranslate"><span class="pre">continuous</span></code> namespace so we can use dot notation to compress
<code class="docutils literal notranslate"><span class="pre">continuous.comp</span> <span class="pre">hf</span> <span class="pre">continuous_fst</span></code> into <code class="docutils literal notranslate"><span class="pre">hf.comp</span> <span class="pre">continuous_fst</span></code> which is actually more readable
since it really reads as composing our assumption and our lemma.
We can do the same for the second component to get continuity of <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">p</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#215;</span> <span class="pre">X,</span> <span class="pre">f</span> <span class="pre">p.2</span></code>. We then assemble
those two continuities using <code class="docutils literal notranslate"><span class="pre">continuous.prod_mk</span></code> to get
<code class="docutils literal notranslate"><span class="pre">(hf.comp</span> <span class="pre">continuous_fst).prod_mk</span> <span class="pre">(hf.comp</span> <span class="pre">continuous_snd)</span> <span class="pre">:</span> <span class="pre">continuous</span> <span class="pre">(&#955;</span> <span class="pre">p</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#215;</span> <span class="pre">X,</span> <span class="pre">(f</span> <span class="pre">p.1,</span> <span class="pre">f</span> <span class="pre">p.2))</span></code>
and compose once more to get our full proof.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#215;</span> <span class="n">X</span><span class="o">,</span> <span class="n">dist</span> <span class="o">(</span><span class="n">f</span> <span class="n">p.1</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">p.2</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">continuous_dist.comp</span> <span class="o">((</span><span class="n">hf.comp</span> <span class="n">continuous_fst</span><span class="o">)</span><span class="bp">.</span><span class="n">prod_mk</span> <span class="o">(</span><span class="n">hf.comp</span> <span class="n">continuous_snd</span><span class="o">))</span>
</pre></div>
</div>
<p>The combination of <code class="docutils literal notranslate"><span class="pre">continuous.prod_mk</span></code> and <code class="docutils literal notranslate"><span class="pre">continuous_dist</span></code> via <code class="docutils literal notranslate"><span class="pre">continuous.comp</span></code> feels clunky,
even when heavily using dot notation as above. A more serious issue is that this nice proof requires a lot of
planning. Lean accepts the above proof term because it is a full term proving a statement which is
definitionally equivalent to our goal, the crucial definition to unfold being that of a composition of functions.
Indeed our target function <code class="docutils literal notranslate"><span class="pre">&#955;</span> <span class="pre">p</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#215;</span> <span class="pre">X,</span> <span class="pre">dist</span> <span class="pre">(f</span> <span class="pre">p.1)</span> <span class="pre">(f</span> <span class="pre">p.2)</span></code> is not presented as a composition.
The proof term we provided proves continuity of <code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">&#8728;</span> <span class="pre">(&#955;</span> <span class="pre">p</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#215;</span> <span class="pre">X,</span> <span class="pre">(f</span> <span class="pre">p.1,</span> <span class="pre">f</span> <span class="pre">p.2))</span></code> which happens
to be definitionally equal to our target function. But if we try to build this proof gradually using
tactics starting with <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">continuous_dist.comp</span></code> then Lean&#8217;s elaborator will fail to recognize a
composition and refuse to apply this lemma. It is especially bad at this when products of types are involved.</p>
<p>A better lemma to apply here is
<code class="docutils literal notranslate"><span class="pre">continuous.dist</span> <span class="pre">{f</span> <span class="pre">g</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">Y}</span> <span class="pre">:</span> <span class="pre">continuous</span> <span class="pre">f</span> <span class="pre">&#8594;</span> <span class="pre">continuous</span> <span class="pre">g</span> <span class="pre">&#8594;</span> <span class="pre">continuous</span> <span class="pre">(&#955;</span> <span class="pre">x,</span> <span class="pre">dist</span> <span class="pre">(f</span> <span class="pre">x)</span> <span class="pre">(g</span> <span class="pre">x))</span></code>
which is nicer to Lean&#8217;s elaborator and also provides a shorter proof when directly providing a full
proof term, as can be seen from the following two new proofs of the above statement:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#215;</span> <span class="n">X</span><span class="o">,</span> <span class="n">dist</span> <span class="o">(</span><span class="n">f</span> <span class="n">p.1</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">p.2</span><span class="o">))</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">apply</span> <span class="n">continuous.dist</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hf.comp</span> <span class="n">continuous_fst</span><span class="o">,</span>
  <span class="n">exact</span> <span class="n">hf.comp</span> <span class="n">continuous_snd</span>
<span class="kd">end</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#215;</span> <span class="n">X</span><span class="o">,</span> <span class="n">dist</span> <span class="o">(</span><span class="n">f</span> <span class="n">p.1</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">p.2</span><span class="o">))</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">hf.comp</span> <span class="n">continuous_fst</span><span class="o">)</span><span class="bp">.</span><span class="n">dist</span> <span class="o">(</span><span class="n">hf.comp</span> <span class="n">continuous_snd</span><span class="o">)</span>
</pre></div>
</div>
<p>Note that, without the elaboration issue coming from composition, another way to compress
our proof would be to use <code class="docutils literal notranslate"><span class="pre">continuous.prod_map</span></code> which is sometimes useful and gives
as an alternate proof term <code class="docutils literal notranslate"><span class="pre">continuous_dist.comp</span> <span class="pre">(hf.prod_map</span> <span class="pre">hf)</span></code> which even shorter to type.</p>
<p>Since it is sad to decide between a version which is better for elaboration and a version which is shorter
to type, let us wrap this discussion with a last bit of compression offered
by <code class="docutils literal notranslate"><span class="pre">continuous.fst'</span></code> which allows to compress <code class="docutils literal notranslate"><span class="pre">hf.comp</span> <span class="pre">continuous_fst</span></code> to <code class="docutils literal notranslate"><span class="pre">hf.fst'</span></code> (and the same with <code class="docutils literal notranslate"><span class="pre">snd</span></code>)
and get our final proof, now bordering obfuscation.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">continuous</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">p</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#215;</span> <span class="n">X</span><span class="o">,</span> <span class="n">dist</span> <span class="o">(</span><span class="n">f</span> <span class="n">p.1</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">p.2</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">hf.fst&#39;.dist</span> <span class="n">hf.snd&#39;</span>
</pre></div>
</div>
<p>It&#8217;s your turn now to prove some continuity lemma. After trying the continuity tactic, you will need
<code class="docutils literal notranslate"><span class="pre">continuous.add</span></code>, <code class="docutils literal notranslate"><span class="pre">continuous_pow</span></code> and <code class="docutils literal notranslate"><span class="pre">continuous_id</span></code> to do it by hand.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8477;</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">continuous</span> <span class="o">(</span><span class="bp">&#955;</span> <span class="n">x</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">,</span> <span class="n">f</span> <span class="o">(</span><span class="n">x</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="n">x</span><span class="o">))</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</pre></div>
</div>
<p>So far we saw continuity as a global notion, but one can also define continuity at a point.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span>
<span class="n">continuous_at</span> <span class="n">f</span> <span class="n">a</span> <span class="bp">&#8596;</span> <span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">&#948;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">x</span><span class="o">},</span> <span class="n">dist</span> <span class="n">x</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">&#948;</span> <span class="bp">&#8594;</span> <span class="n">dist</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="o">:=</span>
<span class="n">metric.continuous_at_iff</span>
</pre></div>
</div>
</section>
<section id="balls-open-sets-and-closed-sets">
<h3><span class="section-number">7.2.2. </span>Balls, open sets and closed sets<a class="headerlink" href="#balls-open-sets-and-closed-sets" title="Permalink to this headline">&#61633;</a></h3>
<p>Once we have a distance function, the most important geometric definitions are (open) balls and closed balls.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">variables</span> <span class="n">r</span> <span class="o">:</span> <span class="n">&#8477;</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">metric.ball</span> <span class="n">a</span> <span class="n">r</span> <span class="bp">=</span> <span class="o">{</span><span class="n">b</span> <span class="bp">|</span> <span class="n">dist</span> <span class="n">b</span> <span class="n">a</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kd">example</span> <span class="o">:</span> <span class="n">metric.closed_ball</span> <span class="n">a</span> <span class="n">r</span> <span class="bp">=</span> <span class="o">{</span><span class="n">b</span> <span class="bp">|</span> <span class="n">dist</span> <span class="n">b</span> <span class="n">a</span> <span class="bp">&#8804;</span> <span class="n">r</span><span class="o">}</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>
</div>
<p>Note that <cite>r</cite> is any real number here, there is no sign restriction. Of course some statements do require a radius condition.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">metric.ball</span> <span class="n">a</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">metric.mem_ball_self</span> <span class="n">hr</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">hr</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">&#8804;</span> <span class="n">r</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">metric.closed_ball</span> <span class="n">a</span> <span class="n">r</span> <span class="o">:=</span> <span class="n">metric.mem_closed_ball_self</span> <span class="n">hr</span>
</pre></div>
</div>
<p>Once we have balls, we can define open sets. They are actually defined in a more general setting covered in the next section,
but we have lemmas recasting the definition is terms of balls.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_open</span> <span class="n">s</span> <span class="bp">&#8596;</span> <span class="bp">&#8704;</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">metric.ball</span> <span class="n">x</span> <span class="n">&#949;</span> <span class="bp">&#8838;</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">metric.is_open_iff</span>
</pre></div>
</div>
<p>Then closed sets are sets whose complement is open. Their important property is they are closed under limits. The closure of a set is the smallest subset containing it.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">s</span> <span class="bp">&#8596;</span> <span class="n">is_open</span> <span class="n">s</span><span class="bp">&#7580;</span> <span class="o">:=</span>
<span class="n">is_open_compl_iff.symm</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">a</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hus</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">hs.mem_of_tendsto</span> <span class="n">hu</span> <span class="o">(</span><span class="n">eventually_of_forall</span> <span class="n">hus</span><span class="o">)</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">closure</span> <span class="n">s</span> <span class="bp">&#8596;</span> <span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">b</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">metric.ball</span> <span class="n">b</span> <span class="n">&#949;</span> <span class="o">:=</span>
<span class="n">metric.mem_closure_iff</span>
</pre></div>
</div>
<p>Do the next exercise without using <cite>mem_closure_iff_seq_limit</cite></p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">a</span><span class="o">))</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">closure</span> <span class="n">s</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</pre></div>
</div>
<p>Remember from the filters sections that neighborhood filters play a big role in mathlib.
In the metric space context, the crucial point is that balls provide bases for those filters.
The main lemmas here are <code class="docutils literal notranslate"><span class="pre">metric.nhds_basis_ball</span></code> and <code class="docutils literal notranslate"><span class="pre">metric.nhds_basis_closed_ball</span></code>
that claim this for open and closed balls with positive radius. The center point is an implicit
argument so we can invoke <code class="docutils literal notranslate"><span class="pre">filter.has_basis.mem_iff</span></code> as in the following example.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">&#8712;</span> <span class="bp">&#120029;</span> <span class="n">x</span> <span class="bp">&#8596;</span> <span class="bp">&#8707;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">metric.ball</span> <span class="n">x</span> <span class="n">&#949;</span> <span class="bp">&#8838;</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">metric.nhds_basis_ball.mem_iff</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">}</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">:</span> <span class="n">s</span> <span class="bp">&#8712;</span> <span class="bp">&#120029;</span> <span class="n">x</span> <span class="bp">&#8596;</span> <span class="bp">&#8707;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">metric.closed_ball</span> <span class="n">x</span> <span class="n">&#949;</span> <span class="bp">&#8838;</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">metric.nhds_basis_closed_ball.mem_iff</span>
</pre></div>
</div>
</section>
<section id="compactness">
<h3><span class="section-number">7.2.3. </span>Compactness<a class="headerlink" href="#compactness" title="Permalink to this headline">&#61633;</a></h3>
<p>Compactness is an important topological notion. It distinguishes subsets of a metric space
that enjoy the same kind of properties as segments in reals compared to other intervals:</p>
<ul class="simple">
<li><p>Any sequence taking value in a compact set has a subsequence that converges in this set</p></li>
<li><p>Any continuous function on a nonempty compact set with values in real numbers is bounded and achieves its bounds somewhere (this is called the extreme values theorem).</p></li>
<li><p>Compact sets are closed sets.</p></li>
</ul>
<p>Let us first check that the unit interval in reals is indeed a compact set, and then check the above
claims for compact sets in general metric spaces. In the second statement we only
need continuity on the given set so we will use <code class="docutils literal notranslate"><span class="pre">continuous_on</span></code> instead of <code class="docutils literal notranslate"><span class="pre">continuous</span></code>, and
we will give separate statements for the minimum and the maximum. Of course all these results
are deduced from more general versions, some of which will be discussed in later sections.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="o">(</span><span class="n">set.Icc</span> <span class="mi">0</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">set</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">is_compact_Icc</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span> <span class="n">n</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8707;</span> <span class="n">a</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">&#966;</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8469;</span><span class="o">,</span> <span class="n">strict_mono</span> <span class="n">&#966;</span> <span class="bp">&#8743;</span> <span class="n">tendsto</span> <span class="o">(</span><span class="n">u</span> <span class="bp">&#8728;</span> <span class="n">&#966;</span><span class="o">)</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">a</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">hs.tendsto_subseq</span> <span class="n">hu</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hs&#39;</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">hfs</span> <span class="o">:</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8707;</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">&#8804;</span> <span class="n">f</span> <span class="n">y</span> <span class="o">:=</span>
<span class="n">hs.exists_forall_le</span> <span class="n">hs&#39;</span> <span class="n">hfs</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">s</span><span class="o">)</span> <span class="o">(</span><span class="n">hs&#39;</span> <span class="o">:</span> <span class="n">s.nonempty</span><span class="o">)</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span><span class="o">}</span> <span class="o">(</span><span class="n">hfs</span> <span class="o">:</span> <span class="n">continuous_on</span> <span class="n">f</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">&#8707;</span> <span class="n">x</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">s</span><span class="o">,</span> <span class="n">f</span> <span class="n">y</span> <span class="bp">&#8804;</span> <span class="n">f</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">hs.exists_forall_ge</span> <span class="n">hs&#39;</span> <span class="n">hfs</span>

<span class="kd">example</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">}</span> <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">is_closed</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">hs.is_closed</span>
</pre></div>
</div>
<p>We can also metric spaces which are globally compact, using an extra <code class="docutils literal notranslate"><span class="pre">Prop</span></code>-valued type class:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_compact</span> <span class="o">(</span><span class="n">univ</span> <span class="o">:</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">compact_univ</span>
</pre></div>
</div>
<p>In a compact metric space any closed set is compact, this is <code class="docutils literal notranslate"><span class="pre">is_compact.is_closed</span></code>.</p>
</section>
<section id="uniformly-continuous-functions">
<h3><span class="section-number">7.2.4. </span>Uniformly continuous functions<a class="headerlink" href="#uniformly-continuous-functions" title="Permalink to this headline">&#61633;</a></h3>
<p>We now turn to uniformity notions on metric spaces : uniformly continuous functions, Cauchy sequences and completeness.
Again those are defined in a more general context but we have lemmas in the metric name space to access their elementary definitions.
We start with uniform continuity.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">Y</span><span class="o">]</span> <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">uniform_continuous</span> <span class="n">f</span> <span class="bp">&#8596;</span>
    <span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">&#948;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="o">{</span><span class="n">a</span> <span class="n">b</span> <span class="o">:</span> <span class="n">X</span><span class="o">},</span> <span class="n">dist</span> <span class="n">a</span> <span class="n">b</span> <span class="bp">&lt;</span> <span class="n">&#948;</span> <span class="bp">&#8594;</span> <span class="n">dist</span> <span class="o">(</span><span class="n">f</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span> <span class="n">b</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="o">:=</span>
<span class="n">metric.uniform_continuous_iff</span>
</pre></div>
</div>
<p>In order to practice manipulating all those definitions, we will prove that continuous
functions from a compact metric space to a metric space are uniformly continuous
(we will see a more general version in a later section).</p>
<p>We will first give an informal sketch. Let <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">Y</span></code> be a continuous function from
a compact metric space to a metric space.
We fix <code class="docutils literal notranslate"><span class="pre">&#949;</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> and start looking for some <code class="docutils literal notranslate"><span class="pre">&#948;</span></code>.</p>
<p>Let <code class="docutils literal notranslate"><span class="pre">&#966;</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#215;</span> <span class="pre">X</span> <span class="pre">&#8594;</span> <span class="pre">&#8477;</span> <span class="pre">:=</span> <span class="pre">&#955;</span> <span class="pre">p,</span> <span class="pre">dist</span> <span class="pre">(f</span> <span class="pre">p.1)</span> <span class="pre">(f</span> <span class="pre">p.2)</span></code> and let <code class="docutils literal notranslate"><span class="pre">K</span> <span class="pre">:=</span> <span class="pre">{</span> <span class="pre">p</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">&#215;</span> <span class="pre">X</span> <span class="pre">|</span> <span class="pre">&#949;</span> <span class="pre">&#8804;</span> <span class="pre">&#966;</span> <span class="pre">p</span> <span class="pre">}</span></code>.
Observe <code class="docutils literal notranslate"><span class="pre">&#966;</span></code> is continuous since <code class="docutils literal notranslate"><span class="pre">f</span></code> and distance are continuous.
And <code class="docutils literal notranslate"><span class="pre">K</span></code> is clearly closed (use <code class="docutils literal notranslate"><span class="pre">is_closed_le</span></code>) hence compact since <code class="docutils literal notranslate"><span class="pre">X</span></code> is compact.</p>
<p>Then we discuss two possibilities using <code class="docutils literal notranslate"><span class="pre">eq_empty_or_nonempty</span></code>.
If <code class="docutils literal notranslate"><span class="pre">K</span></code> is empty then we are clearly done (we can set <code class="docutils literal notranslate"><span class="pre">&#948;</span> <span class="pre">=</span> <span class="pre">1</span></code> for instance).
So let&#8217;s assume <code class="docutils literal notranslate"><span class="pre">K</span></code> is not empty, and use the extreme value theorem to choose <code class="docutils literal notranslate"><span class="pre">(x&#8320;,</span> <span class="pre">x&#8321;)</span></code> attaining the infimum
of <code class="docutils literal notranslate"><span class="pre">&#966;</span></code> on <code class="docutils literal notranslate"><span class="pre">K</span></code>. We can then set <code class="docutils literal notranslate"><span class="pre">&#948;</span> <span class="pre">=</span> <span class="pre">dist</span> <span class="pre">x&#8320;</span> <span class="pre">x&#8321;</span></code> and check everything works.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">[</span><span class="n">compact_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">metric_space</span> <span class="n">Y</span><span class="o">]</span>
  <span class="o">{</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">&#8594;</span> <span class="n">Y</span><span class="o">}</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">continuous</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">uniform_continuous</span> <span class="n">f</span> <span class="o">:=</span>
<span class="gr">sorry</span>
</pre></div>
</div>
</section>
<section id="completeness">
<h3><span class="section-number">7.2.5. </span>Completeness<a class="headerlink" href="#completeness" title="Permalink to this headline">&#61633;</a></h3>
<p>A Cauchy sequence in a metric space is a sequence whose terms get closer and closer to each other.
There are a couple of equivalent ways to state that idea.
In particular converging sequences are Cauchy. The converse is true only in so-called <em>complete</em>
spaces.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">example</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">cauchy_seq</span> <span class="n">u</span> <span class="bp">&#8596;</span>
  <span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">N</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">m</span> <span class="bp">&#8805;</span> <span class="n">N</span><span class="o">,</span>  <span class="bp">&#8704;</span> <span class="n">n</span> <span class="bp">&#8805;</span> <span class="n">N</span><span class="o">,</span> <span class="n">dist</span> <span class="o">(</span><span class="n">u</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">n</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="o">:=</span>
<span class="n">metric.cauchy_seq_iff</span>

<span class="kd">example</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">cauchy_seq</span> <span class="n">u</span> <span class="bp">&#8596;</span> <span class="bp">&#8704;</span> <span class="n">&#949;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="bp">&#8707;</span> <span class="n">N</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">n</span> <span class="bp">&#8805;</span> <span class="n">N</span><span class="o">,</span> <span class="n">dist</span> <span class="o">(</span><span class="n">u</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="n">N</span><span class="o">)</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="o">:=</span>
<span class="n">metric.cauchy_seq_iff&#39;</span>


<span class="kd">example</span> <span class="o">[</span><span class="n">complete_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="n">cauchy_seq</span> <span class="n">u</span><span class="o">)</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">x</span><span class="o">,</span> <span class="n">tendsto</span> <span class="n">u</span> <span class="n">at_top</span> <span class="o">(</span><span class="bp">&#120029;</span> <span class="n">x</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">cauchy_seq_tendsto_of_complete</span> <span class="n">hu</span>
</pre></div>
</div>
<p>We&#8217;ll practice using this definition by proving a convenient criterion which is a special case of a
criterion appearing in mathlib. This is also a good opportunity to practive using big sums in
a geometric context. In addition to the explanations from the filters section, you will probably need
<code class="docutils literal notranslate"><span class="pre">tendsto_pow_at_top_nhds_0_of_lt_1</span></code>, <code class="docutils literal notranslate"><span class="pre">tendsto.mul</span></code> and <code class="docutils literal notranslate"><span class="pre">dist_le_range_sum_dist</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">lemma</span> <span class="n">cauchy_seq_of_le_geometric_two&#39;</span> <span class="o">{</span><span class="n">u</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">X</span><span class="o">}</span>
    <span class="o">(</span><span class="n">hu</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">),</span> <span class="n">dist</span> <span class="o">(</span><span class="n">u</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">))</span> <span class="bp">&#8804;</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">^</span> <span class="n">n</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">cauchy_seq</span> <span class="n">u</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="n">rw</span> <span class="n">metric.cauchy_seq_iff&#39;</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">&#949;</span> <span class="n">&#949;_pos</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">&#10216;</span><span class="n">N</span><span class="o">,</span> <span class="n">hN</span><span class="o">&#10217;</span> <span class="o">:</span> <span class="bp">&#8707;</span> <span class="n">N</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">,</span> <span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span> <span class="bp">^</span> <span class="n">N</span> <span class="bp">*</span> <span class="mi">2</span> <span class="bp">&lt;</span> <span class="n">&#949;</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="n">use</span> <span class="n">N</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">n</span> <span class="n">hn</span><span class="o">,</span>
  <span class="n">obtain</span> <span class="o">&#10216;</span><span class="n">k</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">=</span> <span class="n">N</span> <span class="bp">+</span> <span class="n">k</span><span class="o">&#10217;</span> <span class="o">:=</span> <span class="n">le_iff_exists_add.mp</span> <span class="n">hn</span><span class="o">,</span>
  <span class="k">calc</span> <span class="n">dist</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">N</span> <span class="bp">+</span> <span class="n">k</span><span class="o">))</span> <span class="o">(</span><span class="n">u</span> <span class="n">N</span><span class="o">)</span> <span class="bp">=</span> <span class="n">dist</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">N</span><span class="bp">+</span><span class="mi">0</span><span class="o">))</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">N</span> <span class="bp">+</span> <span class="n">k</span><span class="o">))</span> <span class="o">:</span> <span class="gr">sorry</span>
  <span class="bp">...</span> <span class="bp">&#8804;</span> <span class="bp">&#8721;</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span> <span class="n">k</span><span class="o">,</span> <span class="n">dist</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">N</span> <span class="bp">+</span> <span class="n">i</span><span class="o">))</span> <span class="o">(</span><span class="n">u</span> <span class="o">(</span><span class="n">N</span> <span class="bp">+</span> <span class="o">(</span><span class="n">i</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)))</span> <span class="o">:</span> <span class="gr">sorry</span>
  <span class="bp">...</span> <span class="bp">&#8804;</span> <span class="bp">&#8721;</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span> <span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="mi">2</span> <span class="o">:</span> <span class="n">&#8477;</span><span class="o">)</span><span class="bp">^</span><span class="o">(</span><span class="n">N</span><span class="bp">+</span><span class="n">i</span><span class="o">)</span> <span class="o">:</span> <span class="gr">sorry</span>
  <span class="bp">...</span> <span class="bp">=</span> <span class="mi">1</span><span class="bp">/</span><span class="mi">2</span><span class="bp">^</span><span class="n">N</span><span class="bp">*&#8721;</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span> <span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span> <span class="bp">/</span> <span class="mi">2</span><span class="o">)</span> <span class="bp">^</span> <span class="n">i</span> <span class="o">:</span> <span class="gr">sorry</span>
  <span class="bp">...</span> <span class="bp">&#8804;</span> <span class="mi">1</span><span class="bp">/</span><span class="mi">2</span><span class="bp">^</span><span class="n">N</span><span class="bp">*</span><span class="mi">2</span> <span class="o">:</span> <span class="gr">sorry</span>
  <span class="bp">...</span> <span class="bp">&lt;</span> <span class="n">&#949;</span> <span class="o">:</span> <span class="gr">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
<p>We are ready for the final boss of this section: Baire&#8217;s theorem for complete metric spaces!
The proof skeleton below shows interesting techniques. It uses the <code class="docutils literal notranslate"><span class="pre">choose</span></code> tactic in its exclamation
mark variant (you should experiment with removing this exclamation mark) and it shows how to
define something inductively in the middle of a proof using <code class="docutils literal notranslate"><span class="pre">nat.rec_on</span></code>.</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kn">open</span> <span class="n">metric</span>

<span class="kd">example</span> <span class="o">[</span><span class="n">complete_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">set</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">ho</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">is_open</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">))</span> <span class="o">(</span><span class="n">hd</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">dense</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">))</span> <span class="o">:</span> <span class="n">dense</span> <span class="o">(</span><span class="bp">&#8898;</span><span class="n">n</span><span class="o">,</span> <span class="n">f</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span>
<span class="kd">begin</span>
  <span class="k">let</span> <span class="n">B</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="mi">1</span><span class="bp">/</span><span class="mi">2</span><span class="o">)</span><span class="bp">^</span><span class="n">n</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">Bpos</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">B</span> <span class="n">n</span><span class="o">,</span> <span class="gr">sorry</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"> Translate the density assumption into two functions `center` and `radius` associating</span>
<span class="cm">  to any n, x, &#948;, &#948;pos a center and a positive radius such that</span>
<span class="cm">  `closed_ball center radius` is included both in `f n` and in `closed_ball x &#948;`.</span>
<span class="cm">  We can also require `radius &#8804; (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/</span>
  <span class="k">have</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">&#8469;</span><span class="o">)</span>  <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">&#948;</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">),</span> <span class="bp">&#8707;</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="bp">&gt;</span> <span class="mi">0</span><span class="o">),</span>
    <span class="n">r</span> <span class="bp">&#8804;</span> <span class="n">B</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">&#8743;</span> <span class="n">closed_ball</span> <span class="n">y</span> <span class="n">r</span> <span class="bp">&#8838;</span> <span class="o">(</span><span class="n">closed_ball</span> <span class="n">x</span> <span class="n">&#948;</span><span class="o">)</span> <span class="bp">&#8745;</span> <span class="n">f</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="n">choose</span><span class="bp">!</span> <span class="n">center</span> <span class="n">radius</span> <span class="n">Hpos</span> <span class="n">HB</span> <span class="n">Hball</span> <span class="n">using</span> <span class="n">this</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">rw</span> <span class="n">mem_closure_iff_nhds_basis</span> <span class="n">nhds_basis_closed_ball</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">&#949;</span> <span class="n">&#949;pos</span><span class="o">,</span>
  <span class="c">/-</span><span class="cm"> `&#949;` is positive. We have to find a point in the ball of radius `&#949;` around `x` belonging to all</span>
<span class="cm">  `f n`. For this, we construct inductively a sequence `F n = (c n, r n)` such that the closed ball</span>
<span class="cm">  `closed_ball (c n) (r n)` is included in the previous ball and in `f n`, and such that</span>
<span class="cm">  `r n` is small enough to ensure that `c n` is a Cauchy sequence. Then `c n` converges to a</span>
<span class="cm">  limit which belongs to all the `f n`. -/</span>
  <span class="k">let</span> <span class="n">F</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="o">(</span><span class="n">X</span> <span class="bp">&#215;</span> <span class="n">&#8477;</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">&#955;</span><span class="n">n</span><span class="o">,</span> <span class="n">nat.rec_on</span> <span class="n">n</span> <span class="o">(</span><span class="n">prod.mk</span> <span class="n">x</span> <span class="o">(</span><span class="n">min</span> <span class="n">&#949;</span> <span class="o">(</span><span class="n">B</span> <span class="mi">0</span><span class="o">)))</span>
                              <span class="o">(</span><span class="bp">&#955;</span><span class="n">n</span> <span class="n">p</span><span class="o">,</span> <span class="n">prod.mk</span> <span class="o">(</span><span class="n">center</span> <span class="n">n</span> <span class="n">p.1</span> <span class="n">p.2</span><span class="o">)</span> <span class="o">(</span><span class="n">radius</span> <span class="n">n</span> <span class="n">p.1</span> <span class="n">p.2</span><span class="o">)),</span>
  <span class="k">let</span> <span class="n">c</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">X</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">F</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span>
  <span class="k">let</span> <span class="n">r</span> <span class="o">:</span> <span class="n">&#8469;</span> <span class="bp">&#8594;</span> <span class="n">&#8477;</span> <span class="o">:=</span> <span class="bp">&#955;</span> <span class="n">n</span><span class="o">,</span> <span class="o">(</span><span class="n">F</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">rpos</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">r</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>

  <span class="k">have</span> <span class="n">rB</span> <span class="o">:</span> <span class="bp">&#8704;</span><span class="n">n</span><span class="o">,</span> <span class="n">r</span> <span class="n">n</span> <span class="bp">&#8804;</span> <span class="n">B</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">incl</span> <span class="o">:</span> <span class="bp">&#8704;</span><span class="n">n</span><span class="o">,</span> <span class="n">closed_ball</span> <span class="o">(</span><span class="n">c</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">(</span><span class="n">r</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">&#8838;</span> <span class="o">(</span><span class="n">closed_ball</span> <span class="o">(</span><span class="n">c</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="n">n</span><span class="o">))</span> <span class="bp">&#8745;</span> <span class="o">(</span><span class="n">f</span> <span class="n">n</span><span class="o">),</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">cdist</span> <span class="o">:</span> <span class="bp">&#8704;</span> <span class="n">n</span><span class="o">,</span> <span class="n">dist</span> <span class="o">(</span><span class="n">c</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">c</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="bp">&#8804;</span> <span class="n">B</span> <span class="n">n</span><span class="o">,</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="k">have</span> <span class="o">:</span> <span class="n">cauchy_seq</span> <span class="n">c</span><span class="o">,</span> <span class="k">from</span> <span class="n">cauchy_seq_of_le_geometric_two&#39;</span> <span class="n">cdist</span><span class="o">,</span>
  <span class="c1">-- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.</span>
  <span class="n">rcases</span> <span class="n">cauchy_seq_tendsto_of_complete</span> <span class="n">this</span> <span class="k">with</span> <span class="o">&#10216;</span><span class="n">y</span><span class="o">,</span> <span class="n">ylim</span><span class="o">&#10217;,</span>
  <span class="c1">-- this point `y` will be the desired point. We will check that it belongs to all</span>
  <span class="c1">-- `f n` and to `ball x &#949;`.</span>
  <span class="n">use</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">I</span> <span class="o">:</span> <span class="bp">&#8704;</span><span class="n">n</span><span class="o">,</span> <span class="bp">&#8704;</span> <span class="n">m</span> <span class="bp">&#8805;</span> <span class="n">n</span><span class="o">,</span> <span class="n">closed_ball</span> <span class="o">(</span><span class="n">c</span> <span class="n">m</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="n">m</span><span class="o">)</span> <span class="bp">&#8838;</span> <span class="n">closed_ball</span> <span class="o">(</span><span class="n">c</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="n">n</span><span class="o">),</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="k">have</span> <span class="n">yball</span> <span class="o">:</span> <span class="bp">&#8704;</span><span class="n">n</span><span class="o">,</span> <span class="n">y</span> <span class="bp">&#8712;</span> <span class="n">closed_ball</span> <span class="o">(</span><span class="n">c</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">r</span> <span class="n">n</span><span class="o">),</span>
  <span class="o">{</span> <span class="gr">sorry</span> <span class="o">},</span>
  <span class="gr">sorry</span>
<span class="kd">end</span>
</pre></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="06_Abstract_Algebra.html" class="btn btn-neutral float-left" title="6. Abstract Algebra" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="genindex.html" class="btn btn-neutral float-right" title="Index" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Jeremy Avigad, Kevin Buzzard, Robert Y. Lewis, Patrick Massot.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>